'''
python内置了读写文件相关的函数，用法和C员兼容，在磁盘中读写文件的
操作是系统提供的。python读写文件的的操作是请求系统打开一个文件，然后
再通过操作系统提供的接口在文件中读取或写入数据。
'''
'''
读取文件过程：
1、打开文件
2、读取文件内容
3、关闭文件
'''
'''
1、打开文件
语法格式：open(file [,mode][,encoding][,errors])
file:指定文件路径
文件路径：相对路径：相对当前文件的路径   1-读取文件.py -> 文件操作
                   从当前文件所在的文件夹的路径下开始  
          绝对路径：一个完整的路径   
          C:\\Users\\xlg\\Desktop\\文件操作\\1-读取文件.py
mode:文件的打开方式   默认为 r
r ： 表示以只读的形式打开文件：如果文件不存在，程序报错；如果
    文件存在，文件的定位符放到起始位置。
rb : 表示以只读二进制的形式打开文件：如果文件不存在，程序报错；如果
    文件存在，文件的定位符放到起始位置。
r+ ：表示以读写的形式打开文件：如果文件不存在，程序报错；如果
    文件存在，文件的定位符放到起始位置。
rb+ ：表示以读写二进制的形式打开文件：如果文件不存在，程序报错；如果
    文件存在，文件的定位符放到起始位置。

w ： 表示以只写的形式打开文件：如果文件不存在，创建一个新的文件，文件
    的定位符放到起始位置；如果文件存在，原文件的数据会被清除，文件的
    定位符放到起始位置。
wb ： 表示以只写二进制的形式打开文件：如果文件不存在，创建一个新的文件，文件
    的定位符放到起始位置；如果文件存在，原文件的数据会被清除，文件的
    定位符放到起始位置。
w+ ： 表示以读写的形式打开文件：如果文件不存在，创建一个新的文件，文件
    的定位符放到起始位置；如果文件存在，原文件的数据会被清除，文件的
    定位符放到起始位置。
wb+ ： 表示读只写二进制的形式打开文件：如果文件不存在，创建一个新的文件，文件
    的定位符放到起始位置；如果文件存在，原文件的数据会被清除，文件的
    定位符放到起始位置。

a ： 表示以只写（追加写入字符）的形式打开文件：如果文件不存在，创建
    一个新的文件，文件的定位符放到起始位置；如果文件存在，
    原文件的数据不会被清除，文件的定位符放到末尾位置。
ab ： 表示以只写（追加写入字符）二进制的形式打开文件：如果文件不存在，创建
    一个新的文件，文件的定位符放到起始位置；如果文件存在，
    原文件的数据不会被清除，文件的定位符放到末尾位置。
a+ ： 表示以读写（追加写入字符）的形式打开文件：如果文件不存在，创建
    一个新的文件，文件的定位符放到起始位置；如果文件存在，
    原文件的数据不会被清除，文件的定位符放到末尾位置。
ab+ ： 表示以读写（追加写入字符）二进制的形式打开文件：如果文件不存在，创建
    一个新的文件，文件的定位符放到起始位置；如果文件存在，
    原文件的数据不会被清除，文件的定位符放到末尾位置。

encoding ： 文件的编码格式， 通常分为UTF-8
errors：字符错误处理方式
    ignore：忽略非法字符
    strict：默认方式，如果遇到非法字符，抛出异常
    replace：用?代替非法字符

open：存在返回值，返回文件整体描述  
'''
'''
1、打开文件
'''
# 打开普通文件
# FileNotFoundError: [Errno 2] No such file or directory: 'file.txt'
# 当文件不存在时，抛出异常
f1 = open(file="file.txt",mode="r")
# print(f1)
# 指定编码格式打开文件
f2 = open(file="file.txt", mode="r", encoding="utf-8")
# print(f2)
# 指定错误处理方式
f3 = open(file="file.txt", mode="r", encoding="utf-8", errors="ignore")
# print(f3)
# 打开二进制格式的文件（存放字节）,不能设置encoding
f4 = open(file="file.txt", mode="rb")
# ValueError: binary mode doesn't take an encoding argument
# print(f4)
print("*****************************************************************************************")
'''
2、读取数据
存在返回值，将读取到的内容返回
'''
# read([n])  读取n个字符，以r的形式打开的文件，一个字母/数字/汉字为一个
# 字符
# 1、read()  读取文件中所有的内容
str1 = f3.read()
print(str1)
print("*****************************************************************************************")
# 2、read(n)  读取n个字符
# read会记录当前文件的定位符，每次读取时，实是从上一次的读取之后继续
# 读取数据
str2 = f3.read(4)
print(str2)
str3 = f3.read(4)
print(str3)
print("*****************************************************************************************")
# readline([n])
# 3、读取整行,包括"\n"
str4 = f3.readline()
print(str4) # ....\n
str5 = f3.readline()
print(str5)
print("***********---------------------------------------------************************")
# 4、readline(n)  读取n个字符
str6 = f3.readline(3)
print(str6)
str7 = f3.readline(4)
print(str7)
print("*****************************************************************************************")
# readlines([n])
# 5、读取所有的行，返回一个列表，将每行的内容作为列表的一个元素
list8 = f3.readlines()
print(list8)
print("*****************************************************************************************")
# 6、如果给定的n大于0，实际返回的字符个数可能n大，因为readlines读取数据
# 会读取一整行，读取的数据会有缓冲区。
list9 = f3.readlines(14)
print(list9)
print("*****************************************************************************************")
# 7、修改定位符的位置  seek(n)  按字节算
# 返回当前定位符的位置  tell()  按字节算
# utf-8编码格式下：数字字母为一个字节，汉字为3个字节
# gbk编码格式下：数字字母为一个字节，汉字为2个字节
print(f3.tell())
f3.seek(3)
print(f3.tell())
print(f3.read(4))
print(f3.tell())

'''
3、关闭文件   close()
'''
'''
当文件使用结束后必须将该文件关闭，因为文件在打开的状态下会占据系统
资源，系统在同一时间打开的文件个数有限。
'''
# 已经关闭的文件不能再继续使用
f3.close()
f1.close()
f2.close()
f4.close()

# ValueError: I/O operation on closed file.
# str1 = f3.read()
# print(str1)
print("*****************************************************************************************")
print("*****************************************************************************************")
# 一个完整的过程
try:
    f5 = open(file="file.txt", mode="r", encoding="utf-8")
    print(f5.read())
except FileNotFoundError:
    print("文件不存在")
else:
    f5.close()

# 简写
# with与try的写法效果一致，代码是相对简单，而且系统会自动执行close()
with open(file="file.txt", mode="r", encoding="utf-8", errors="ignore") as f6:
    print(f6.read())





















